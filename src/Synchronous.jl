# This allows Synchronous belt transmissions to be modeled, providing specific calculation and optimization methods

export SynchronousBelt, pitchLength2NTeeth, nTeeth2PitchLength#, belt2NTeeth, belt2PitchLength

"""
  Represents a synchronous belt with parameters:
  `profile::String` - tooth profile name
  `pitch::AbstractLength` - distance between belt grooves
  `length::AbstractLength` - belt linear length if cut
  `nTeeth::Int` - number of teeth over the length
  `width::AbstractLength` - belt width
  `partNumber::String` - reference name
  `supplier::String` - reference name
  `url::String` - sourcing link
  `id::UUID` - unique id
"""
struct SynchronousBelt <: AbstractBelt
  # arrive::AbstractPulley
  # depart::AbstractPulley
  #    or 
  # segments::Vector{Segment}
  """Name of the tooth profile"""
  profile::String 
  """Distance between belt teeth"""
  pitch::AbstractLength 
  """Belt linear length if cut"""
  length::AbstractLength 
  """Number of teeth on the belt"""
  nTeeth::Int 
  """Width of the belt"""
  width::AbstractLength 
  """Reference part number"""
  partNumber::String 
  """Reference supplier"""
  supplier::String 
  """Reference sourcing url"""
  url::String 
  """Autogenerated unique id"""
  id::UUIDs.UUID
end 

@kwdispatch SynchronousBelt() 

# 220526: KeywordDispatch can't have default arguments: https://github.com/simonbyrne/KeywordDispatch.jl/issues/1 , so iterate
"""
    SynchronousBelt(; pitch::AbstractLength, length::AbstractLength, nTeeth::Int,  width::AbstractLength, profile::String, partNumber::String, supplier::String, url::String, id::UUID )
    SynchronousBelt(; pitch::AbstractLength, length::AbstractLength,               width::AbstractLength, profile::String)
    SynchronousBelt(; pitch::AbstractLength,                         nTeeth::Int,  width::AbstractLength, profile::String)
  Creates a SynchronousBelt with tooth `pitch`, overall `length`, `nTeeth`, belt `width` and `profile` name.
"""
@kwmethod SynchronousBelt(; pitch::AbstractLength, length::AbstractLength, nTeeth::Int,  width::AbstractLength, profile::String, partNumber::String, supplier::String, url::String, id::UUID ) = SynchronousBelt( profile, pitch, length, nTeeth, width, partNumber, supplier, url, id)

@kwmethod SynchronousBelt(; pitch::AbstractLength, length::AbstractLength,               width::AbstractLength, profile::String) = SynchronousBelt( profile, pitch, length, pitchLength2NTeeth(pitch=pitch, length=length), width, "pn00", "spA", "url0", UUIDs.uuid4() )

@kwmethod SynchronousBelt(; pitch::AbstractLength, nTeeth::Int,                          width::AbstractLength, profile::String) = SynchronousBelt( profile, pitch, nTeeth2PitchLength(pitch=pitch, nTeeth=nTeeth), nTeeth,                width, "pn00", "spA", "url0", UUIDs.uuid4() )

"""
    SynchronousBelt( belt::SynchronousBelt; partNumber="", supplier="", url="" ) :: SynchronousBelt
  A copy constructor for adding/changing `partNumber`, `supplier`, or `url`.
  """
function SynchronousBelt( belt::SynchronousBelt; partNumber="", supplier="", url="" ) :: SynchronousBelt
  pn = belt.partNumber
  if partNumber != ""
      pn = partNumber
  end
  sp = belt.supplier
  if supplier != ""
      sp = supplier
  end
  ur = belt.url
  if url != ""
      ur = url
  end
  return SynchronousBelt( belt.profile, belt.pitch, belt.length, belt.nTeeth, belt.width, pn, sp, ur, belt.id )
end

@testitem "SynchronousBelt constructors" begin
  using UnitTypes, Geometry2D, UUIDs
  ba = SynchronousBelt(pitch=MilliMeter(2), length=MilliMeter(54), width=MilliMeter(6), profile="gt2")
  bb = SynchronousBelt(pitch=MilliMeter(2), nTeeth=27, width=MilliMeter(6), profile="gt2")
  @test ba.pitch == bb.pitch
  @test ba.length == bb.length
  @test ba.id != bb.id
  @test ba.id == tryparse(UUID, string(ba.id))
end

@testitem "SynchronousBelt copy constructor" begin
  using UnitTypes, Geometry2D
  ba = SynchronousBelt(pitch=MilliMeter(2), length=MilliMeter(54), width=MilliMeter(6), profile="gt2")
  bs = SynchronousBelt( ba, supplier="SDP/SI", url="https://sdpsi.com/", partNumber="135-246")
  @test ba.id == bs.id
  @test bs.partNumber == "135-246"
  @test bs.supplier == "SDP/SI"
  @test bs.url == "https://sdpsi.com/"
end


"""
    pitchLength2NTeeth(; pitch::AbstractLength, length::AbstractLength )::Integer
  `nTeeth` is simply `length`/`pitch`.
"""
function pitchLength2NTeeth(; pitch::AbstractLength, length::AbstractLength )::Integer
  return convert(Int64, round(toBaseFloat(length)/toBaseFloat(pitch)))
end

@testitem "pitchLength2NTeeth" begin
  using UnitTypes, Geometry2D
  @test pitchLength2NTeeth(pitch=MilliMeter(2), length=MilliMeter(54)) == 27
  @test pitchLength2NTeeth(pitch=MilliMeter(2), length=MilliMeter(54.4)) == 27
  @test pitchLength2NTeeth(pitch=MilliMeter(2), length=MilliMeter(53.6)) == 27
end


"""
    nTeeth2PitchLength(; pitch::AbstractLength, nTeeth::Integer) :: AbstractLength
  Belt `length` is `pitch` * `nTeeth`.
"""
function nTeeth2PitchLength(; pitch::AbstractLength, nTeeth::Integer) :: AbstractLength
  return pitch * nTeeth
end
@testitem "nTeeth2PitchLength" begin
  using UnitTypes, Geometry2D
  @test nTeeth2PitchLength(pitch=MilliMeter(2), nTeeth=27) == MilliMeter(54)
  @test nTeeth2PitchLength(pitch=MilliMeter(2), nTeeth=28) == MilliMeter(56)
  @test nTeeth2PitchLength(pitch=MilliMeter(2), nTeeth=26) == MilliMeter(52)
end



export SynchronousPulley, nGrooves2Radius, radius2NGrooves, nGrooves2Length

"""
  Models a SynchronousPulley in a BeltTransmission, described by a `pitch` circle, rotation `axis`, and `beltPitch`.
  $FIELDS
"""
struct SynchronousPulley <: AbstractPulley
  """Circle describing the pulley pitch diameter."""
  pitch::Geometry2D.Circle

  """The rotation axis for the pulley with +/- defining the 'positive' rotation direction."""
  axis::Geometry2D.UnitVector 

  """Distance between belt teeth"""
  beltPitch::AbstractLength #[mm/groove] -- would like a Synchrounous meta-class to provide these definitions, not sure if this is allowed

  """Angle of the radial vector of the belt's point of arrival."""
  arrive::Geometry2D.Radian

  """Angle of the radial vector of the belt's point of departure."""
  depart::Geometry2D.Radian

  """Convenience name of the pulley."""
  name::String
end

"""
    SynchronousPulley(center::Geometry2D.Point2D, axis::Geometry2D.UnitVector, nGrooves::Integer, beltPitch::AbstractLength, name::String)
  Models a SynchronousPulley in a BeltTransmission located at `center` rotating about `axis` with `nGrooves`(=nTeeth) spaced with arc length `beltPitch` and covenience `name`.
"""
SynchronousPulley(center::Geometry2D.Point2D, axis::Geometry2D.UnitVector, nGrooves::Integer, beltPitch::AbstractLength, name::String) = SynchronousPulley(Geometry2D.Circle(center, nGrooves2Radius(beltPitch, nGrooves)),axis,beltPitch, Radian(0), Radian(0), name) 

"""
    SynchronousPulley(sp::SynchronousPulley, arrive=Radian(0), depart=Radian(0))
  A copy constructor for setting the `arrive` and `depart` angles.
"""
SynchronousPulley(sp::SynchronousPulley, arrive=Radian(0), depart=Radian(0)) = SynchronousPulley(sp.pitch,sp.axis,sp.beltPitch,arrive,depart,sp.name) #copy constructor

@kwdispatch SynchronousPulley() #kwdispatch can't have default arguments, so define first with everything, then narrow:

"""
    SynchronousPulley(; center::Geometry2D.Point2D, axis::Geometry2D.UnitVector, nGrooves::Integer, beltPitch::AbstractLength, arrive::Geometry2D.Radian, depart::Geometry2D.Radian, name::String)
    SynchronousPulley(; center::Geometry2D.Point2D, axis::Geometry2D.UnitVector, nGrooves::Integer, beltPitch::AbstractLength, name::String)
  Models a SynchronousPulley in a BeltTransmission, described by a `circle`, rotation `axis`, and `name`.
  `nGrooves` and `beltPitch` are used to find the pulley pitch diameter.
  The belt's `arrive` and `depart` angles are the polar angles about the pulley axis of the belt's arrival and departure contact points, usually found by [calculateRouteAngles()](#calculateRouteAngles)
"""
@kwmethod SynchronousPulley(; center::Geometry2D.Point2D, axis::Geometry2D.UnitVector, nGrooves::Integer, beltPitch::AbstractLength, arrive::Geometry2D.Radian, depart::Geometry2D.Radian, name::String) = SynchronousPulley(Geometry2D.Circle(center, nGrooves2Radius(beltPitch, nGrooves)), axis, beltPitch, arrive, depart, name) 
@kwmethod SynchronousPulley(; center::Geometry2D.Point2D, axis::Geometry2D.UnitVector, nGrooves::Integer, beltPitch::AbstractLength, name::String) = SynchronousPulley(Geometry2D.Circle(center, nGrooves2Radius(beltPitch, nGrooves)),axis,beltPitch, Radian(0), Radian(0), name) 

@testitem "SynchronousPulley constructors" begin
  using UnitTypes, Geometry2D
  ctr = Geometry2D.Point2D(MilliMeter(3),MilliMeter(5))

  tp = SynchronousPulley(ctr, Geometry2D.uk, 10, MilliMeter(2), "B")
  @test typeof(tp) <: AbstractPulley

  pA = SynchronousPulley(center=Geometry2D.Point2D(MilliMeter(100),MilliMeter(100)), axis=Geometry2D.uk, nGrooves=62, beltPitch=MilliMeter(2), name="A" )
  tp = SynchronousPulley(center=ctr, axis=Geometry2D.uk, nGrooves=10, beltPitch=MilliMeter(2), name="H")
  @test typeof(tp) <: AbstractPulley

  @test pitchLength( tp ) ≈ MilliMeter(20)
end

"""
    nGrooves2Radius(pitch::AbstractLength, nGrooves::Integer)::AbstractLength
  Convert the `pitch` and `nGrooves` to the pitch radius.
"""
function nGrooves2Radius(pitch::AbstractLength, nGrooves::Integer)::AbstractLength
  return (nGrooves*pitch)/(2*pi)
end

@testitem "nGrooves2Radius" begin
  using UnitTypes
  @test nGrooves2Radius(MilliMeter(2), 10) == MilliMeter(20/2/pi)
end


"""
    radius2NGrooves(p::SynchronousPulley)::Integer
    radius2NGrooves(pitch::AbstractLength, radius::AbstractLength)::Integer
  Convert the `pitch` and `radius` to the number of grooves.
"""
function radius2NGrooves(p::SynchronousPulley)::Integer
  return radius2NGrooves(p.beltPitch, p.pitch.radius)
end
function radius2NGrooves(pitch::AbstractLength, radius::AbstractLength)::Integer
    return convert(Int32,round(2*pi*toBaseFloat(radius)/toBaseFloat(pitch)))
end

@testitem "radius2NGrooves" begin
  using UnitTypes, Geometry2D
  @test radius2NGrooves(MilliMeter(2), MilliMeter(10)) == round(2*pi*10/2)
end


"""
    nGrooves2Length(pitch::AbstractLength, nGrooves::Integer)::AbstractLength
  Convert the `pitch` and `nGrooves` to the circumferential length.
"""
function nGrooves2Length(pitch::AbstractLength, nGrooves::Integer)::AbstractLength
  return pitch * nGrooves
end
@testitem "nGrooves2Length" begin
  using UnitTypes, Geometry2D
  @test nGrooves2Length(MilliMeter(2), 10) == MilliMeter(20)
end



# """ coerce the given radius to the nearest radius having an integer number of grooves """
#function coerceRadius(pitch::AbstractLength, radius::AbstractLength) :: AbstractLength
#  return nGrooves2Radius( pitch, radius2NGrooves(pitch, radius))
#end

"""
    pulley2String(p::SynchronousPulley) :: String
  Returns a descriptive string of the given SynchronousPulley `p` of the form:
    SynchronousPulley[struct] @ [1.000mm,2.000mm] r[3.000mm] arrive[57.296°] depart[114.592°] aWrap[57.296°] lWrap[3.000mm]"
"""
function pulley2String(p::SynchronousPulley)::String 
  wa = Degree(calculateWrappedAngle(p))
  wl = calculateWrappedLength(p)
  return @sprintf("SynchronousPulley[%s] @ [%3.3f%s,%3.3f%s] r[%3.3f%s]=[%dgrooves] arrive[%3.3f°] depart[%3.3f°] aWrap[%3.3f°] lWrap[%3.3f%s]",
    p.name, 
    p.pitch.center.x.value, p.pitch.center.x.unit,
    p.pitch.center.y.value, p.pitch.center.y.unit,
    p.pitch.radius.value, p.pitch.radius.unit,
    radius2NGrooves(p),
    Degree(p.arrive).value, Degree(p.depart).value,
    wa.value,
    wl.value, wl.unit
    )
end
@testitem "pulley2String" begin
  using UnitTypes, Geometry2D
  p = SynchronousPulley(center=Geometry2D.Point2D(MilliMeter(1), MilliMeter(2)), nGrooves=10, axis=Geometry2D.uk, beltPitch=MilliMeter(2), arrive=Radian(1), depart=Radian(2), name="struct" ) 
  @test pulley2String(p) == "SynchronousPulley[struct] @ [1.000mm,2.000mm] r[3.183mm]=[10grooves] arrive[57.296°] depart[114.592°] aWrap[57.296°] lWrap[3.183mm]"
end



